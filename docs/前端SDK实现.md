# 前端SDK实现

**负责人：刘骐铜**

## 白板与物体

对于每个白板总共会创建两个画布，一个是上层画布（upper-canvas），一个是下层画布（lower-canvas），两个画布是一样大的，还有一个外层 div 将这两个 canvas 包起来。上层画布主要用于处理一些交互事件，比如鼠标事件、涂鸦模式（画板）、左键拖拽产生的框选区域等；下层画布则**单纯**的用于绘制所有物体，简单粗暴的遍历所有物体进行绘制。 如果通过上层画布的交互后，某些物体的某些属性值被改变了，这时候就会清空下层画布，重新绘制所有物体，两层画布各司其职，典型的数据驱动视图。

![img](https://t7chv86kzc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQyMDJiMWFjNWVmMzI1NWM5NzQwZjY4ZmRkMTFjOTNfbjd6RFZaZjZlc1k2M1dDOFF3bHFuQmE0U0ZkZ0l6eThfVG9rZW46Ym94Y253a25Fb3pXUlZvaFdaUDcwY2J4YUk5XzE2NjgzNTM4Njk6MTY2ODM1NzQ2OV9WNA)

抽象出一个物体基类，归纳出一些它们的共性。要绘制某个物体，就是在画布的某个位置（top、left值）根据某些属性（宽高大小等）画上某个物体（比如矩形、多边形、图片或者路径等等），并且之后还可以对每个物体进行一些交互操作（主要就是平移+旋转+缩放）。抽象出一个物体基类（FabricObject），其它物体（如 Rect）只需要继承这个物体基类，就能够很方便的拥有一些通用能力。

物体的绘制被分成了两步：`transform` 和 `_render`。**不去改变物体的宽高和大小，而是通过各种变换来达到所需要的效果。**

物体还需要支持边框和控制点的绘制，边框用xis-aligned bounding box，也就是**边平行于坐标轴**的包围盒，取物体所有顶点（也可叫做离散点）坐标的最大最小值。九个控制点边框差不多，计算下每个控制点的位置（各个顶点和中点），其实就是画9 个矩形。

当鼠标 hover 到物体上时，我们会改变鼠标的样式使其变成移动的样子；当 hover 到控制点时则会变成对应的操作样式；当 click 物体时，会将物体变成激活态，也就是展示边框和控制点。这个主要由射线检测法来实现。同时为了防止多个用户同时操作同一个图形，会有图元锁避免一个图形同时被多个用户激活。

## 框选

物体的框选功能，拖蓝选区（鼠标拖拽区域）其实就是个普通矩形，这个区域由鼠标按下的点和拖动的终点组成，通过这两点就能够确认一个规规矩矩的矩形（边和 xy 轴平行），所有的交互都是在上层画布进行的，所以它应该绘制在上层画布，并且这样可以避免重绘所有的物体。判断两个矩形是否相交最根本的就是判断两条边是否相交。

## 交互

拖拽平移：每个物体都是有 top 和 left 值来表示物体位置的，所以平移的时候只需要简单的更新下物体的 top 和 left 值即可，然后每次移动都会触发 renderAll 方法进行重新渲染。

旋转：每个物体都是有一个 angle 变量来表示物体旋转角度的，当对物体进行旋转操作的时候，我们可以先计算出拖拽旋转的角度 deltaAngle，于是`新的 angle = 旧的 angle + deltaAngle`，然后重新赋值 angle 变量。

缩放。不会去改变物体自身的大小，而是去修改物体的变换值，所以缩放的本质也仅仅是改变物体的 scaleX 和 scaleY 值。`当前宽度 = 鼠标位置的 x - 左边中间控制点的位置的 x`。scaleX = 当前宽度 / 自身宽度。

## 协同

依靠ws和发布订阅模式，我们要构造的就是这样一个对象，eventObj 相当于一个事件管理中心，当我们触发相应 eventName 的事件时（发布），就会找到 eventObj 里面 eventName 对应的那个数组，然后将里面的回调函数 cb 挨个遍历执行即可。最终发布订阅中心这个类被其余所有类继承，

## 性能优化

1、超出画布可视区我们就不进行绘制

2、减少指令代码：

同绘制一样，指令的执行也是有成本的，所以能少一点是一点。比如一般我们画一个新的图形都会调用一次 beginPath，这样比较好保证每个图形互不干扰。但如果画的是 n 条连续的线段，我们就不用一直 beginPath 了，只要在一开始调用一次就行，绘制内容一多，省下来的时间还是很可观的。